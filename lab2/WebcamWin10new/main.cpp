// main.cpp
#include <windows.h>                // WinAPI базовые функции и типы
#include <objbase.h>                // COM инициализация/типы
#include <iostream>                 
#include <string>                   
#include <vector>                   
#include <optional>                 
#include <locale>                   // локали 
#include <codecvt>                  // преобразования кодировок

#include <shlwapi.h>                // PathIsRelative, PathRemoveFileSpec
#pragma comment(lib, "shlwapi.lib") // линковка shlwapi

#include <mfapi.h>                  // Media Foundation API
#include <mfidl.h>                  // MF интерфейсы
#include <mfobjects.h>              // MF объекты
#include <mfreadwrite.h>            // source/sink reader/writer
#include <mftransform.h>            // MFT типы
#include <mferror.h>                // HRESULT MF коды
#pragma comment(lib, "mfplat.lib")  // линковка MF
#pragma comment(lib, "mf.lib")
#pragma comment(lib, "mfreadwrite.lib")
#pragma comment(lib, "mfuuid.lib")

#include <wincodec.h>               // WIC (запись JPEG)
#pragma comment(lib, "windowscodecs.lib")

#include <wrl/client.h>             // ComPtr
using Microsoft::WRL::ComPtr;       // удобный тип для COM указателей

#include "CommandLine.h"            // парсер аргументов
#include "Logger.h"                 // централизованный логгер
#include "DeviceEnumerator.h"       // перечисление камер
#include "FrameGrabber.h"           // снимок в JPEG
#include "VideoRecorder.h"          // запись видео в MP4
#include "MFHelpers.h"              // вспомогательные MF утилиты
#include "ScopeGuard.h"             // RAII для очистки

using namespace std;                

// Возвращает полный путь к исполняемому файлу
static wstring GetExePath() {
    wchar_t buf[MAX_PATH]{};                        // буфер пути
    GetModuleFileNameW(nullptr, buf, MAX_PATH);     // заполняет путь exe
    return wstring(buf);                            // возвращает std::wstring
}

// Нормализует и создаёт выходную директорию
static wstring NormalizeOutputPath(const optional<wstring>& outArg, const wstring& exePath) {
    wchar_t cur[MAX_PATH]{};                        
    GetCurrentDirectoryW(MAX_PATH, cur);            // текущая директория
    wstring out;
    if (!outArg.has_value()) out = wstring(cur);    // если нет --output -> CWD
    else {
        wstring v = outArg.value();                 // значение аргумента
        if (v == L".") {                            // "." -> директория exe
            wchar_t exedir[MAX_PATH];
            wcscpy_s(exedir, exePath.c_str());     // копируем exe path
            PathRemoveFileSpecW(exedir);           // убираем файл exe
            out = exedir;                          // используем папку exe
        }
        else if (PathIsRelativeW(v.c_str())) {     // относительный путь
            out = wstring(cur) + L"\\" + v;        // делаем абсолютным
        }
        else out = v;                              // уже абсолютный путь
    }
    CreateDirectoryW(out.c_str(), nullptr);        // создаёт директорию при необходимости
    return out;                                    // возвращает итоговый путь
}

// Формирует имя файла с таймстампом и расширением
static wstring MakeFilename(const wstring& dir, const wstring& ext) {
    SYSTEMTIME st;
    GetLocalTime(&st);                              // текущее локальное время
    wchar_t buf[128];
    swprintf_s(buf, L"%04d-%02d-%02d_%02d-%02d-%02d%s",
        st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, ext.c_str()); // формат YYYY-MM-DD_hh-mm-ss.ext
    wstring path = dir;
    if (!path.empty() && path.back() != L'\\' && path.back() != L'/') path += L"\\"; // добавляем слэш если нужно
    path += buf;                                    // добавляем имя файла
    return path;                                    // возвращаем полный путь
}

// У процесса нет консоли — аллоцируем и перенаправляем stdio
static bool EnsureConsole() {
    if (GetConsoleWindow()) return false;           // если консоль уже есть — ничего не делаем
    if (!AllocConsole()) return false;              // пытаемся выделить новую консоль
    FILE* fOut = nullptr;
    freopen_s(&fOut, "CONOUT$", "w", stdout);       // перенаправляем stdout в консоль
    freopen_s(&fOut, "CONOUT$", "w", stderr);       // перенаправляем stderr
    FILE* fIn = nullptr;
    freopen_s(&fIn, "CONIN$", "r", stdin);          // перенаправляем stdin
    std::ios::sync_with_stdio(false);               // отключаем синхронизацию i/o
    SetConsoleOutputCP(CP_UTF8);                    // ставим кодовую страницу UTF-8 для вывода
    SetConsoleCP(CP_UTF8);                          // ставим кодовую страницу UTF-8 для ввода
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);  // дескриптор стандартного вывода
    if (hOut && hOut != INVALID_HANDLE_VALUE) {
        DWORD mode = 0;
        if (GetConsoleMode(hOut, &mode)) {          // читаем текущий режим консоли
            mode |= ENABLE_PROCESSED_OUTPUT;       // включаем стандартную обработку вывода
            SetConsoleMode(hOut, mode);            // записываем новый режим
        }
    }
    return true;                                    // консоль была выделена
}

// Если консоль была выделена этой программой — ждём нажатия Enter
static void PauseIfConsoleAllocated(bool allocated) {
    if (!allocated) return;                         // если конcоль не наша — не ждём
    Logger::Instance().Info(L"\nНажмите Enter для выхода...");      // приглашение для пользователя
    std::wcout.flush();                             // сбрасываем буфер
    HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE); // дескриптор stdin
    if (hStdin && hStdin != INVALID_HANDLE_VALUE) {
        wchar_t buf[16] = { 0 };
        DWORD read = 0;
        ReadConsoleW(hStdin, buf, (DWORD)(std::size(buf) - 1), &read, nullptr); // читаем wide ввод
    }
    else {
        std::wstring dummy;
        std::getline(std::wcin, dummy);            // откат на стандартный ввод
    }
}

int wmain(int argc, wchar_t** argv) {
    std::wstring parseErr;
    auto opt = CommandLineParser::Parse(argc, argv, parseErr); // парсим аргументы
    if (!opt) {
        MessageBoxW(nullptr, parseErr.c_str(), L"Ошибка запуска", MB_ICONERROR); // показ ошибки при плохом парсинге
        return -1;                                   // завершаем с ошибкой
    }

    bool wantConsole = !opt->quiet;                  // хотим консоль если не задан --quiet
    bool consoleAllocated = false;
    if (wantConsole) consoleAllocated = EnsureConsole(); // аллоцируем консоль

    auto exePath = GetExePath();                     // путь к исполняемому файлу

    // Инициализируем централизованный логгер
    Logger::Instance().InitConsole(wantConsole, opt->verbose); // включаем/отключаем консоль и verbose
    Logger::Instance().Info(L"Программа запущена");         // короткое стартовое сообщение

    Logger::Instance().Verbose(L"Parse success");            // парсинг успешен

    HRESULT hr = MFStartup(MF_VERSION);               // инициализация Media Foundation
    if (FAILED(hr)) {
        Logger::Instance().Error(L"MFStartup failed: HRESULT=" + to_wstring((long)hr)); // логируем ошибку
        PauseIfConsoleAllocated(consoleAllocated);  // ждём Enter 
        return -1;                                  // выходим с ошибкой
    }
    ScopeGuard mfGuard([&] { MFShutdown(); });      // гарантируем MFShutdown при выходе

    DeviceEnumerator de;                            // объект для перечисления устройств

    if (opt->info) {                                // режим --info: печать списка устройств
        auto devices = de.ListDevices();            // получаем список
        if (devices.empty()) {
            Logger::Instance().Info(L"Не найдено ни одной веб-камеры"); 
        }
        else {
            for (size_t i = 0; i < devices.size(); ++i) {
                const auto& d = devices[i];
                if (wantConsole) {                   
                    std::wcout << L"[" << i << L"] " << d.name << L"\n";  // имя устройства
                    std::wcout << L"  id: " << d.id << L"\n";             // id / символьная ссылка
                    std::wcout << L"  vendor: " << (d.vendor.empty() ? L"(unknown)" : d.vendor) << L"\n"; // vendor
                    std::wcout << L"  formats:\n";                        // заголовок форматов
                    for (const auto& f : d.formats) {
                        wchar_t buf[256];
                        swprintf_s(buf, L"    %ux%u @ %u/%u fps subtype: %ls bitDepth:%u\n",
                            f.width, f.height, f.fpsNumerator, f.fpsDenominator,
                            GuidToString(f.subtype).c_str(), f.bitDepth);  // строка формата
                        std::wcout << buf;                                 // печатаем формат
                    }
                    std::wcout << L"\n";
                }
                Logger::Instance().Verbose(L"Device[" + std::to_wstring(i) + L"] " + d.name); 
            }
        }
        PauseIfConsoleAllocated(consoleAllocated);    // пауза
        return 0;                                     // выходим после перечисления
    }

    wstring outDir = NormalizeOutputPath(opt->outputPath, exePath); // нормализуем output путь
    int devIdx = opt->deviceId.value_or(0);          // индекс устройства (по умолчанию 0)

    if (opt->snap) {                                 // режим --snap: сделать снимок
        wstring filePath = MakeFilename(outDir, L".jpg"); // имя выходного файла
        FrameGrabber fg(devIdx);                      // создаём объект FrameGrabber
        std::wstring usedDevName;
        VideoFormatInfo usedFmt{};
        Logger::Instance().Verbose(L"Starting CaptureToJpeg: device=" + to_wstring(devIdx) + L" out=" + filePath);

        HRESULT r = fg.CaptureToJpeg(filePath, 95, &usedDevName, &usedFmt); // основной вызов захвата
        Logger::Instance().Verbose(L"CaptureToJpeg returned HRESULT=" + to_wstring((long)r)); // verbose результат

        if (FAILED(r)) {
            Logger::Instance().Error(L"CaptureToJpeg failed. HRESULT=" + to_wstring((long)r)); // логируем ошибку
            PauseIfConsoleAllocated(consoleAllocated);  // пауза
            return (int)r;                              // возвращаем HRESULT как код выхода
        }

        Logger::Instance().Info(L"Фото сохранено: " + filePath); // сообщение об успехе
        PauseIfConsoleAllocated(consoleAllocated);      // пауза и выход
        return 0;
    }

    if (opt->capture) {                                     // режим --capture: запись видео
        wstring tmpPath = MakeFilename(outDir, L".tmp");    // временный файл для SinkWriter
        wstring finalPath = MakeFilename(outDir, L".mp4");  // итоговый файл
        VideoRecorder vr(devIdx);                           // создаём VideoRecorder
        std::wstring usedDevName;
        VideoFormatInfo usedFmt{};
        Logger::Instance().Verbose(L"Starting RecordToFile: device=" + to_wstring(devIdx) + L" final=" + finalPath);

        HRESULT r = vr.RecordToFile(tmpPath, finalPath, opt->captureSeconds, &usedDevName, &usedFmt); // запись
        Logger::Instance().Verbose(L"RecordToFile returned HRESULT=" + to_wstring((long)r)); // verbose результат

        if (FAILED(r)) {
            Logger::Instance().Error(L"RecordToFile failed. HRESULT=" + to_wstring((long)r)); // лог ошибки
            DeleteFileW(tmpPath.c_str());                   // чистим временный файл при ошибке
            PauseIfConsoleAllocated(consoleAllocated);      // пауза если нужно
            return (int)r;                                  // возвращаем код ошибки
        }

        Logger::Instance().Info(L"Видео сохранено: " + finalPath); // сообщение об успехе
        PauseIfConsoleAllocated(consoleAllocated);  // пауза и выход
        return 0;
    }

    Logger::Instance().Info(L"Не выбрано действие. Укажите --info, --snap или --capture"); // подсказка по использованию
    PauseIfConsoleAllocated(consoleAllocated);      // пауза 
    return 0;                                       // выход без ошибки
}