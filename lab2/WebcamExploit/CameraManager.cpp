#include "CameraManager.h"



CameraManager::CameraManager() {
    initMediaFoundation();
}

CameraManager::~CameraManager() {
    shutdownMediaFoundation();
}

void CameraManager::initMediaFoundation() {
    MFStartup(MF_VERSION);
}

void CameraManager::shutdownMediaFoundation() {
    MFShutdown();
}

void CameraManager::printInfo(bool quiet) {
    if (quiet) return;

    IMFAttributes* pAttributes = nullptr;
    IMFActivate** ppDevices = nullptr;
    UINT32 count = 0;

    // Убрать дублирующие вызовы MFStartup/MFShutdown
    MFCreateAttributes(&pAttributes, 1);
    pAttributes->SetGUID(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE,
        MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID);

    HRESULT hr = MFEnumDeviceSources(pAttributes, &ppDevices, &count);
    if (SUCCEEDED(hr)) {
        for (UINT32 i = 0; i < count; i++) {
            WCHAR* szFriendlyName = nullptr;
            UINT32 cchName = 0;

            if (SUCCEEDED(ppDevices[i]->GetAllocatedString(
                MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME,
                &szFriendlyName, &cchName))) {
                wprintOut(L"Камера: " + std::wstring(szFriendlyName) + L"\n");
                CoTaskMemFree(szFriendlyName);
            }

            // ... остальная информация о камере ...

            ppDevices[i]->Release(); // Важно: освободить каждый элемент
        }
        CoTaskMemFree(ppDevices); // Освободить массив
    }

    pAttributes->Release();
}

void CameraManager::snap(const std::wstring& outputPath, bool quiet) {
    IMFMediaSource* pSource = nullptr;
    IMFSourceReader* pReader = nullptr;

    try {
        if (!quiet) {
            std::wstring msg = L"Сохраняем снимок в " + outputPath + L"\n";
            wprintOut(msg);
        }

        // 1. Получить первую доступную камеру
        IMFActivate* pDevice = getFirstCamera();
        if (!pDevice) {
            throw std::wstring(L"Не найдены доступные камеры");
        }

        // 2. Активировать медиа-источник
        HRESULT hr = pDevice->ActivateObject(IID_PPV_ARGS(&pSource));
        if (FAILED(hr)) {
            pDevice->Release();
            throw std::wstring(L"Ошибка активации камеры");
        }

        // 3. Создать Source Reader
        hr = MFCreateSourceReaderFromMediaSource(pSource, nullptr, &pReader);
        if (FAILED(hr)) {
            throw std::wstring(L"Ошибка создания Source Reader");
        }

        // 4. Настроить формат вывода (RGB32)
        configureSourceReader(pReader);

        // 5. Захватить кадр и сохранить
        captureAndSaveFrame(pReader, outputPath);

        pDevice->Release();
        pReader->Release();
        pSource->Release();

    }
    catch (const std::wstring& e) {
        if (pReader) pReader->Release();
        if (pSource) pSource->Release();
        throw e;
    }
}

void CameraManager::capture(int seconds, const std::wstring& outputPath, bool quiet) {
    // Заглушка: здесь нужно реализовать запись видео через IMFSourceReader + IMFWriter
    if (!quiet) {
        std::wstring msg = L"Записываем видео "
            + std::to_wstring(seconds)
            + L" сек. в "
            + outputPath
            + L"\n";

        wprintOut(msg);

    }
    std::this_thread::sleep_for(std::chrono::seconds(seconds));
}

IMFActivate* CameraManager::getFirstCamera() {
        IMFAttributes* pAttributes = nullptr;
        IMFActivate** ppDevices = nullptr;
        UINT32 count = 0;
        IMFActivate* pFirstDevice = nullptr;

        MFCreateAttributes(&pAttributes, 1);
        pAttributes->SetGUID(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE,
            MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID);

        if (SUCCEEDED(MFEnumDeviceSources(pAttributes, &ppDevices, &count)) && count > 0) {
            pFirstDevice = ppDevices[0];
            pFirstDevice->AddRef(); // Добавляем ссылку

            // Освобождаем остальные устройства и массив
            for (UINT32 i = 1; i < count; i++) {
                ppDevices[i]->Release();
            }
            CoTaskMemFree(ppDevices);
        }

        pAttributes->Release();
        return pFirstDevice;
    }

void CameraManager::configureSourceReader(IMFSourceReader* pReader) {
        IMFMediaType* pType = nullptr;

        // Установить формат RGB32
        MFCreateMediaType(&pType);
        pType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);
        pType->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB32);

        pReader->SetCurrentMediaType(0, nullptr, pType);
        pType->Release();
    }

void CameraManager::captureAndSaveFrame(IMFSourceReader* pReader, const std::wstring& outputPath) {
    IMFSample* pSample = nullptr;
    DWORD streamIndex, flags;
    LONGLONG timestamp;

    // Получаем информацию о формате из SourceReader
    IMFMediaType* pMediaType = nullptr;
    UINT32 width = 0, height = 0;
    LONG stride = 0;
    GUID videoFormat;

    HRESULT hr = pReader->GetCurrentMediaType(0, &pMediaType);
    if (SUCCEEDED(hr) && pMediaType) {
        MFGetAttributeSize(pMediaType, MF_MT_FRAME_SIZE, &width, &height);
        pMediaType->GetGUID(MF_MT_SUBTYPE, &videoFormat);

        // Получаем stride
        hr = pMediaType->GetUINT32(MF_MT_DEFAULT_STRIDE, (UINT32*)&stride);
        if (FAILED(hr)) {
            // Рассчитываем stride по умолчанию
            if (videoFormat == MFVideoFormat_RGB32 || videoFormat == MFVideoFormat_ARGB32) {
                stride = width * 4;
            }
            else if (videoFormat == MFVideoFormat_RGB24) {
                stride = width * 3;
            }
            else {
                stride = width * 4; // fallback
            }
        }
        pMediaType->Release();

        if (!quiet) {
            std::wcout << L"Формат кадра: " << width << L"x" << height
                << L", формат: " << (videoFormat == MFVideoFormat_RGB32 ? L"RGB32" : L"Другой")
                << L", stride: " << stride << std::endl;
        }
    }
    else {
        throw std::wstring(L"Не удалось получить информацию о формате кадра");
    }

    // Пропустить несколько кадров для инициализации камеры
    if (!quiet) {
        std::wcout << L"Инициализация камеры..." << std::endl;
    }

    for (int i = 0; i < 10; i++) { // Увеличим до 10 кадров для инициализации
        hr = pReader->ReadSample(0, 0, &streamIndex, &flags, &timestamp, &pSample);
        if (SUCCEEDED(hr) && pSample) {
            pSample->Release();
            pSample = nullptr;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    if (!quiet) {
        std::wcout << L"Захватываем кадр для сохранения..." << std::endl;
    }

    // Захватить кадр для сохранения
    hr = pReader->ReadSample(0, 0, &streamIndex, &flags, &timestamp, &pSample);

    if (FAILED(hr)) {
        std::wstring errorMsg = L"Ошибка ReadSample: HRESULT = " + std::to_wstring(hr);
        if (!quiet) {
            std::wcerr << errorMsg << std::endl;
        }
        throw errorMsg;
    }

    if (flags & MF_SOURCE_READERF_ENDOFSTREAM) {
        throw std::wstring(L"Конец потока достигнут");
    }

    if (flags & MF_SOURCE_READERF_ERROR) {
        throw std::wstring(L"Ошибка в источнике");
    }

    if (pSample) {
        saveSampleToImage(pSample, outputPath, width, height, videoFormat, stride);
        pSample->Release();

        if (!quiet) {
            std::wcout << L"Снимок успешно сохранен в: " << outputPath << std::endl;
        }
    }
    else {
        throw std::wstring(L"ReadSample успешен, но sample = nullptr");
    }
}

void CameraManager::saveSampleToImage(IMFSample* pSample, const std::wstring& outputPath,
    UINT32 width, UINT32 height, const GUID& videoFormat, LONG stride) {
    IMFMediaBuffer* pBuffer = nullptr;
    BYTE* pData = nullptr;
    DWORD maxLength = 0, currentLength = 0;

    HRESULT hr = pSample->ConvertToContiguousBuffer(&pBuffer);
    if (FAILED(hr)) {
        throw std::wstring(L"Ошибка получения буфера из sample");
    }

    hr = pBuffer->Lock(&pData, &maxLength, &currentLength);
    if (FAILED(hr)) {
        pBuffer->Release();
        throw std::wstring(L"Ошибка блокировки буфера");
    }

    try {
        // Для получения информации о формате нам нужен доступ к SourceReader
        // Временно используем значения по умолчанию - их нужно будет получить извне
        UINT32 width = 1920;
        UINT32 height = 1080;
        LONG stride = width * 4; // Для RGB32
        GUID videoFormat = MFVideoFormat_RGB32;

        // В реальном коде эти значения должны передаваться как параметры
        // или получаться из другого контекста

        if (width == 0 || height == 0) {
            throw std::wstring(L"Не удалось определить размер кадра");
        }

        // Определяем формат кодирования по расширению файла
        GUID containerFormat = GUID_ContainerFormatPng;
        std::wstring extension = outputPath.substr(outputPath.find_last_of(L'.') + 1);

        if (extension == L"jpg" || extension == L"jpeg") {
            containerFormat = GUID_ContainerFormatJpeg;
        }
        else if (extension == L"bmp") {
            containerFormat = GUID_ContainerFormatBmp;
        }
        else if (extension == L"tiff" || extension == L"tif") {
            containerFormat = GUID_ContainerFormatTiff;
        }
        else if (extension == L"gif") {
            containerFormat = GUID_ContainerFormatGif;
        }

        // Создаем WIC компоненты
        IWICImagingFactory* pFactory = nullptr;
        IWICBitmapEncoder* pEncoder = nullptr;
        IWICBitmapFrameEncode* pFrameEncode = nullptr;
        IWICStream* pStream = nullptr;

        hr = CoCreateInstance(
            CLSID_WICImagingFactory,
            nullptr,
            CLSCTX_INPROC_SERVER,
            IID_PPV_ARGS(&pFactory)
        );

        if (FAILED(hr)) {
            throw std::wstring(L"Ошибка создания WIC factory");
        }

        // Создаем encoder
        hr = pFactory->CreateEncoder(containerFormat, nullptr, &pEncoder);
        if (FAILED(hr)) {
            pFactory->Release();
            throw std::wstring(L"Ошибка создания encoder для формата: " + extension);
        }

        // Создаем поток для файла
        hr = pFactory->CreateStream(&pStream);
        if (FAILED(hr)) {
            pEncoder->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка создания потока");
        }

        hr = pStream->InitializeFromFilename(outputPath.c_str(), GENERIC_WRITE);
        if (FAILED(hr)) {
            pStream->Release();
            pEncoder->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка создания файла: " + outputPath);
        }

        // Инициализируем encoder с потоком
        hr = pEncoder->Initialize(pStream, WICBitmapEncoderNoCache);
        if (FAILED(hr)) {
            pStream->Release();
            pEncoder->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка инициализации encoder");
        }

        // Создаем frame для кодирования
        hr = pEncoder->CreateNewFrame(&pFrameEncode, nullptr);
        if (FAILED(hr)) {
            pEncoder->Release();
            pStream->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка создания frame encoder");
        }

        // Инициализируем frame
        hr = pFrameEncode->Initialize(nullptr);
        if (FAILED(hr)) {
            pFrameEncode->Release();
            pEncoder->Release();
            pStream->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка инициализации frame encoder");
        }

        // Устанавливаем размер
        hr = pFrameEncode->SetSize(width, height);
        if (FAILED(hr)) {
            pFrameEncode->Release();
            pEncoder->Release();
            pStream->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка установки размера frame");
        }

        // Определяем WIC формат пикселей на основе видео формата
        WICPixelFormatGUID pixelFormat = GUID_WICPixelFormat32bppBGRA;
        if (videoFormat == MFVideoFormat_RGB32) {
            pixelFormat = GUID_WICPixelFormat32bppBGR;
        }
        else if (videoFormat == MFVideoFormat_RGB24) {
            pixelFormat = GUID_WICPixelFormat24bppBGR;
        }
        else if (videoFormat == MFVideoFormat_ARGB32) {
            pixelFormat = GUID_WICPixelFormat32bppBGRA;
        }

        hr = pFrameEncode->SetPixelFormat(&pixelFormat);
        if (FAILED(hr)) {
            pFrameEncode->Release();
            pEncoder->Release();
            pStream->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка установки формата пикселей");
        }

        // Записываем данные пикселей
        hr = pFrameEncode->WritePixels(
            height,      // число строк
            stride,      // stride (шаг сканирования)
            currentLength, // размер данных
            pData        // данные пикселей
        );

        if (FAILED(hr)) {
            pFrameEncode->Release();
            pEncoder->Release();
            pStream->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка записи пикселей");
        }

        // Завершаем кодирование frame
        hr = pFrameEncode->Commit();
        if (FAILED(hr)) {
            pFrameEncode->Release();
            pEncoder->Release();
            pStream->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка коммита frame");
        }

        // Завершаем кодирование всего файла
        hr = pEncoder->Commit();
        if (FAILED(hr)) {
            pFrameEncode->Release();
            pEncoder->Release();
            pStream->Release();
            pFactory->Release();
            throw std::wstring(L"Ошибка коммита encoder");
        }

        // Освобождаем ресурсы
        pFrameEncode->Release();
        pEncoder->Release();
        pStream->Release();
        pFactory->Release();

    }
    catch (...) {
        pBuffer->Unlock();
        pBuffer->Release();
        throw;
    }

    pBuffer->Unlock();
    pBuffer->Release();
}

void CameraManager::getCurrentMediaTypeInfo(IMFSourceReader* pReader, UINT32& width, UINT32& height, GUID& videoFormat) {
        IMFMediaType* pMediaType = nullptr;
        HRESULT hr = pReader->GetCurrentMediaType(0, &pMediaType);
        if (FAILED(hr)) {
            throw std::wstring(L"Ошибка получения медиа-типа");
        }

        hr = MFGetAttributeSize(pMediaType, MF_MT_FRAME_SIZE, &width, &height);
        if (FAILED(hr)) {
            pMediaType->Release();
            throw std::wstring(L"Ошибка получения размера кадра");
        }

        hr = pMediaType->GetGUID(MF_MT_SUBTYPE, &videoFormat);
        if (FAILED(hr)) {
            pMediaType->Release();
            throw std::wstring(L"Ошибка получения формата видео");
        }

        pMediaType->Release();
    }